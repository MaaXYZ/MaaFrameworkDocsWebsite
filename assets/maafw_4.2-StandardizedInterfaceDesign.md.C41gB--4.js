import{_ as o,c as a,o as e,a2 as t}from"./chunks/framework.DYZYzxF5.js";const p=JSON.parse('{"title":"标准化高级语言面向对象接口设计指南","description":"","frontmatter":{},"headers":[],"relativePath":"maafw/4.2-StandardizedInterfaceDesign.md","filePath":"maafw/4.2-标准化接口设计.md"}'),i={name:"maafw/4.2-StandardizedInterfaceDesign.md"};function n(r,l,s,d,c,g){return e(),a("div",null,l[0]||(l[0]=[t('<h1 id="标准化高级语言面向对象接口设计指南" tabindex="-1">标准化高级语言面向对象接口设计指南 <a class="header-anchor" href="#标准化高级语言面向对象接口设计指南" aria-label="Permalink to &quot;标准化高级语言面向对象接口设计指南&quot;">​</a></h1><p>MaaFW 的绑定（binding）设计可以分为两个步骤：</p><ol><li><strong>标准化 C API 的 OOP 封装</strong>：由于 MaaFW 接口相对稳定，完成封装后无需频繁维护。</li><li><strong>高级封装与回调解析</strong>：在标准化封装基础上，解析回调参数（如 message、detail json、pipeline_override 等），并根据更新动态调整封装。随着 MaaFW 的更新，这部分需要持续维护。</li></ol><p>开发者可以根据自身需求和时间选择其中一种方式，为 MaaFW 添加某语言的封装。</p><h2 id="标准化接口设计" tabindex="-1">标准化接口设计 <a class="header-anchor" href="#标准化接口设计" aria-label="Permalink to &quot;标准化接口设计&quot;">​</a></h2><ol><li><p><strong>对象化接口封装</strong>：</p><ul><li>MaaTasker、MaaResource、MaaController 等应设计为面向对象的接口，而非过程化的调用。例如 MaaContextGetTasker 需要返回对象而非 handle。</li><li>可采用两种模型： <ol><li>创建全局 handle-对象引用字典，通过 handle 查找并返回对应对象。</li><li>对象保持无状态，负责引用 handle，直接创建新对象返回。（参考 Python binding 中的 <code>own</code> 字段）</li></ol></li></ul></li><li><p><strong>异步任务封装</strong>：</p><ul><li>MaaTaskId、MaaCtrlId、MaaResId 等异步 ID 不直接返回给集成方，而是封装成 Job 类，提供 <code>wait</code>、<code>status</code>、<code>get</code> 等方法。</li></ul></li><li><p><strong>Job 类封装</strong>：</p><ul><li>Job 类需封装基于 ID 的所有操作方法。例如 TaskJob 的 <code>get</code> 方法需返回 MaaTaskerGetTaskDetail 查询结果的封装。</li></ul></li><li><p><strong>查询类 ID 封装</strong>：</p><ul><li>MaaRecoId、MaaNodeId 等查询 ID 不直接返回，需通过 MaaTaskerGetRecoDetail 等接口查询，并封装为 RecoDetail、NodeDetail 等结构体返回。</li></ul></li><li><p><strong>回调封装</strong>：</p><ul><li>CustomAction、CustomRecognition、NotificationCallback 等需包装为虚基类。实际传递给 MaaFW 的是 agent 对象中的指针，由 agent 负责将参数转换为常用类型再交给集成方。</li></ul></li><li><p><strong>参数结构封装</strong>：</p><ul><li>CustomAction、CustomRecognition 的 agent 中，将 MaaCustomRecognitionCallback/MaaCustomActionCallback 的参数封装成结构体，避免 Callback 参数变化导致兼容性问题。返回值同样需要封装。</li></ul></li><li><p><strong>独立接口设计</strong>：</p><ul><li>SetOption 中的每个枚举应拆分为独立接口，例如 <code>set_screenshot_target_long_side</code>，而不直接暴露枚举值给集成方。</li></ul></li><li><p><strong>缓冲区封装</strong>：</p><ul><li>StringBuffer、ImageBuffer 等不直接暴露给集成方，需转换为对应语言的字符串或图像类型后返回。</li></ul></li><li><p><strong>引用管理</strong>：</p><ul><li>在 BindResource、BindController、RegisterCustom 等接口中保持引用，防止被 GC（垃圾回收）。</li></ul></li><li><p><strong>结构体数组返回</strong>：</p><ul><li>MaaToolkit 中的 Find 系列接口直接返回封装后的结构体数组。</li></ul></li><li><p><strong>提供样例</strong>：</p><ul><li>样例代码需展示的接口调用不少于 Python 版样例。</li></ul></li></ol><h2 id="额外的回调解析封装" tabindex="-1">额外的回调解析封装 <a class="header-anchor" href="#额外的回调解析封装" aria-label="Permalink to &quot;额外的回调解析封装&quot;">​</a></h2><ol><li><p><strong>回调解析与派发</strong>：</p><ul><li>NotificationCallback 需解析 message 并派发至不同方法（参考 MaaMsg.h），如 <code>on_resource_loading_starting(data)</code>。也可考虑将 ResourceLoading 作为事件枚举，Starting 作为类型枚举进行派发，如 <code>on_notification(event, type, data)</code>。<code>data</code> 为 detail_json 解析后的结构体，而非原始 JSON。</li></ul></li><li><p><strong>未知消息处理</strong>：</p><ul><li>可以增加 <code>on_unknown_notification</code> 方法，以应对未来可能新增的消息。同时，解析出的结构体中可加入 <code>raw</code> 字段或其他方式来表示未知内容。</li></ul></li><li><p><strong>结果解析</strong>：</p><ul><li><code>MaaTaskerGetRecognitionDetail</code> 获取的 detail_json 需拆分为 <code>all_results</code>、<code>filtered_results</code> 和 <code>best_result</code>（注意 best 可能为 null），并根据算法解析为不同的结构体。</li></ul></li><li><p><strong>更多内容待补充</strong>：TODO...</p></li></ol>',8)]))}const _=o(i,[["render",n]]);export{p as __pageData,_ as default};
